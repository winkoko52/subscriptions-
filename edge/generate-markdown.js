import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const projectRoot = path.resolve(__dirname, '..');

const resultsPath = path.join(projectRoot, 'all_working_proxies.txt');
const outputPath = path.join(projectRoot, 'sub', 'ProxyIP-Daily.md');
const outputDir = path.dirname(outputPath);

const countryFlags = {
  'United States': 'üá∫üá∏',
  'United Kingdom': 'üá¨üáß',
  Germany: 'üá©üá™',
  France: 'üá´üá∑',
  Netherlands: 'üá≥üá±',
  Canada: 'üá®üá¶',
  Australia: 'üá¶üá∫',
  Japan: 'üáØüáµ',
  Singapore: 'üá∏üá¨',
  'South Korea': 'üá∞üá∑',
  India: 'üáÆüá≥',
  China: 'üá®üá≥',
  Russia: 'üá∑üá∫',
  Brazil: 'üáßüá∑',
  Turkey: 'üáπüá∑',
  T√ºrkiye: 'üáπüá∑',
  Spain: 'üá™üá∏',
  Iran: 'üáÆüá∑',
  Italy: 'üáÆüáπ',
  Poland: 'üáµüá±',
  Ukraine: 'üá∫üá¶',
  Sweden: 'üá∏üá™',
  Norway: 'üá≥üá¥',
  Denmark: 'üá©üá∞',
  Finland: 'üá´üáÆ',
  Switzerland: 'üá®üá≠',
  Austria: 'üá¶üáπ',
  Belgium: 'üáßüá™',
  'Czech Republic': 'üá®üáø',
  Hungary: 'üá≠üá∫',
  Romania: 'üá∑üá¥',
  Bulgaria: 'üáßüá¨',
  Greece: 'üá¨üá∑',
  Portugal: 'üáµüáπ',
  Ireland: 'üáÆüá™',
  Israel: 'üáÆüá±',
  'United Arab Emirates': 'üá¶üá™',
  'Saudi Arabia': 'üá∏üá¶',
  'Hong Kong': 'üá≠üá∞',
  Taiwan: 'üáπüáº',
  'The Netherlands': 'üá≥üá±',
  Thailand: 'üáπüá≠',
  Vietnam: 'üáªüá≥',
  Malaysia: 'üá≤üáæ',
  Indonesia: 'üáÆüá©',
  Philippines: 'üáµüá≠',
  'South Africa': 'üáøüá¶',
  Egypt: 'üá™üá¨',
  Morocco: 'üá≤üá¶',
  Argentina: 'üá¶üá∑',
  Chile: 'üá®üá±',
  Mexico: 'üá≤üáΩ',
  Colombia: 'üá®üá¥',
  Peru: 'üáµüá™',
  'New Zealand': 'üá≥üáø',
};

function groupProxiesByCountry(proxies) {
  const grouped = {};

  proxies.forEach(proxy => {
    const country = proxy.country || 'Unknown';
    if (!grouped[country]) {
      grouped[country] = [];
    }
    grouped[country].push(proxy);
  });

  return grouped;
}

function generateStats(proxies) {
  const countries = new Set(proxies.map(p => p.country)).size;
  const methods = {};

  proxies.forEach(proxy => {
    const method = proxy.method || 'Unknown';
    methods[method] = (methods[method] || 0) + 1;
  });

  return { countries, methods };
}

async function enrichProxyData(proxies) {
  const enrichedProxies = [];

  for (const proxy of proxies) {
    try {
      const response = await fetch(
        `http://ip-api.com/json/${proxy.ip}?fields=status,country,city,as,proxy,timezone,isp,org`,
        {
          headers: { 'User-Agent': 'Mozilla/5.0 (compatible; ProxyTester/1.0)' },
          signal: AbortSignal.timeout(10000),
        },
      );

      if (response.ok) {
        const data = await response.json();
        if (data.status === 'success') {
          enrichedProxies.push({
            ...proxy,
            country: data.country || proxy.country,
            city: data.city || proxy.city,
            as: data.as || proxy.as,
            isp: data.isp || data.org || proxy.as,
            timezone: data.timezone,
            proxy: data.proxy || 'unknown',
          });
        } else {
          enrichedProxies.push(proxy);
        }
      } else {
        enrichedProxies.push(proxy);
      }

      await new Promise(res => setTimeout(res, 100));
    } catch (error) {
      enrichedProxies.push(proxy);
    }
  }

  return enrichedProxies;
}

try {
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  let proxies = [];
  if (fs.existsSync(resultsPath)) {
    const rawContent = fs.readFileSync(resultsPath, 'utf-8');
    if (rawContent.trim() !== '') {
      const lines = rawContent.split(/\r?\n/).filter(line => line.trim() !== '');
      proxies = lines
        .map(line => {
          try {
            return JSON.parse(line);
          } catch (e) {
            console.log(`Failed to parse line: ${line}`);
            return null;
          }
        })
        .filter(proxy => proxy !== null);
    }
  }

  console.log('Enriching proxy data...');
  // proxies = await enrichProxyData(proxies);

  proxies.sort((a, b) => {
    const countryCompare = (a.country || '').localeCompare(b.country || '');
    if (countryCompare !== 0) return countryCompare;
    return (a.ip || '').localeCompare(b.ip || '');
  });

  const stats = generateStats(proxies);
  const groupedByCountry = groupProxiesByCountry(proxies);

  const currentDate = new Date();
  const nextUpdateDate = new Date(currentDate.getTime() + 48 * 60 * 60 * 1000);

  let markdownContent = `# üó∫Ô∏è Daily Proxy Test Results (Only Port 443)\n\n`;

  markdownContent += `> [!NOTE]\n>\n`;
  markdownContent += `> **Generated by Diana**\n>\n`;
  markdownContent += `> <br/>\n>\n`;
  markdownContent += `> **Last updated:** ${currentDate.toUTCString()}\n>\n`;
  markdownContent += `> <br/>\n>\n`;
  markdownContent += `> **Next update:** ${nextUpdateDate.toUTCString()}\n>\n`;
  markdownContent += `> <br/>\n>\n\n`;

  markdownContent += `</br>\n\n`;

  markdownContent += `## üìä Summary\n\n`;
  markdownContent += `**üîπ Total working proxies:** ${proxies.length}  \n`;
  markdownContent += `**üîπ Countries covered:** ${stats.countries}  \n`;
  markdownContent += `**üîπ Different ports:** 1  \n`;
  markdownContent += `**üîπ Success methods:** ${Object.entries(stats.methods)
    .map(([method, count]) => `${method} (${count})`)
    .join(', ')}\n\n`;

  markdownContent += `<br/>\n\n`;

  markdownContent += `## üîå Ports Distribution\n\n`;
  markdownContent += `| Port | Count | Percentage |\n`;
  markdownContent += `|------|-------|------------|\n`;
  markdownContent += `| 443  | ${proxies.length}     | 100.0%     |\n\n`;

  markdownContent += `<br/>\n\n`;

  if (proxies.length > 0) {
    markdownContent += `## ü´ß Working Proxies by Country\n\n`;
    markdownContent += `<br/>\n\n`;

    const sortedCountries = Object.entries(groupedByCountry).sort(
      ([, a], [, b]) => b.length - a.length,
    );

    sortedCountries.forEach(([country, countryProxies]) => {
      const flag = countryFlags[country] || 'üåç';
      markdownContent += `### ${flag} ${country} (${countryProxies.length} proxies)\n\n`;
      markdownContent += `| Proxy IP | City | ISP / Organization | Method |\n`;
      markdownContent += `|----------|------|--------------------|--------|\n`;

      countryProxies.forEach(proxy => {
        const ip = proxy.ip || 'N/A';
        const city = proxy.city || 'N/A';
        const method = proxy.method || 'N/A';
        const isp = (proxy.isp || proxy.as || 'N/A').substring(0, 50);

        markdownContent += `| \`${ip}\` | ${city} | ${isp} | ${method} |\n`;
      });

      markdownContent += `\n`;
    });

    markdownContent += `<br/>\n\n`;

    markdownContent += `## üìã All Working Proxies (Copy-Friendly Format)\n\n`;
    markdownContent += `<details>\n<summary>Click to expand RAW data</summary>\n\n`;
    markdownContent += `\`\`\`\n`;
    proxies.forEach(proxy => {
      markdownContent += `${proxy.ip}\n`;
    });
    markdownContent += `\`\`\`\n\n`;
    markdownContent += `</details>\n\n`;

    markdownContent += `<br/>\n\n`;

    markdownContent += `## üíæ JSON Format\n\n`;
    markdownContent += `<details>\n<summary>Click to expand JSON data</summary>\n\n`;
    markdownContent += `\`\`\`json\n`;
    markdownContent += JSON.stringify(proxies, null, 2);
    markdownContent += `\n\`\`\`\n\n`;
    markdownContent += `</details>\n`;
  } else {
    markdownContent += `## ‚ùå No Working Proxies Found\n\n`;
    markdownContent += `No working proxies were found in this test run. This could be due to:\n\n`;
    markdownContent += `- Network connectivity issues\n`;
    markdownContent += `- All proxies in the input file are currently offline\n`;
    markdownContent += `- The proxy test criteria may be too strict\n\n`;
  }

  fs.writeFileSync(outputPath, markdownContent);
  console.log(
    `Successfully generated ${path.basename(outputPath)} with ${proxies.length} proxies.`,
  );

  const statsFile = path.join(projectRoot, 'proxy-stats.json');
  const statsData = {
    lastUpdate: new Date().toISOString(),
    nextUpdate: nextUpdateDate.toISOString(),
    totalProxies: proxies.length,
    countries: stats.countries,
    methods: stats.methods,
    topCountries: Object.entries(groupedByCountry)
      .sort(([, a], [, b]) => b.length - a.length)
      .slice(0, 10)
      .map(([country, proxiesInCountry]) => ({
        country,
        flag: countryFlags[country] || 'üåç',
        count: proxiesInCountry.length,
      })),
  };

  fs.writeFileSync(statsFile, JSON.stringify(statsData, null, 2));
} catch (error) {
  console.error('An error occurred in generate-markdown.js:', error);
  process.exit(1);
}
